// Owner: fcole@onshape.com
// v8 version: 4.2.77, ia32
// Flags: --allow-natives-syntax

function boom(a1, a2) {
  // Do something with a2 that needs a map check (for DOUBLE_ELEMENTS).
  var s = a2[0];
  // Emit a load that transitions a1 to FAST_ELEMENTS.
  var t = a1[0];
  // Emit a store to a2 that assumes DOUBLE_ELEMENTS.
  // The map check is considered redundant and will be eliminated.
  a2[0] = 0.3;
}

// Prepare type feedback for the "t = a1[0]" load: fast elements.
var fast_elem = new Array(1);
fast_elem[0] = "tagged";
boom(fast_elem, [1]);

// Prepare type feedback for the "a2[0] = 0.3" store: double elements.
var double_elem = new Array(1);
double_elem[0] = 0.1;
boom(double_elem, double_elem);

%OptimizeFunctionOnNextCall(boom);
boom(double_elem, double_elem);

print(double_elem);	// or any kinds of access double_elem[0] (i.e, var k = double_elem[0];)


/*
   SetDataProperty
     -> WriteDataValue
       -> SetValueInferType
         -> UpdatedType
	   -> HeapType

   Runtime type feedback information is recorded by and stored in the inline caches.
   Type feedback information is expressed internally as an 8-bit value.
   The type field of each HValue, to help in type inference.

   **Element kind confusion -> invalid stores into arrays.
   ** Having two HValues referring to the same array,
      and having one of them transition the array's element kind,
      which the other doesn't realize.

   ** HCheckTableEntry

   at last stmt, we access double_elem with typed_feedback.
   fast_elem + double_element ==> SetValueInferType with strange address.

   optimization ==> generate optimized code ==> type confusion 
   		==> strange value, out of bound of type map address


*/
